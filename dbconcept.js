// Generated by Haxe 4.1.5
(function ($hx_exports, $global) { "use strict";
$hx_exports["database"] = $hx_exports["database"] || {};
$hx_exports["schema"] = $hx_exports["schema"] || {};
$hx_exports["source"] = $hx_exports["source"] || {};
$hx_exports["transform"] = $hx_exports["transform"] || {};
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
}
EReg.__name__ = true;
Object.assign(EReg.prototype, {
	__class__: EReg
});
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
class Lambda {
	static array(it) {
		let a = [];
		let i = $getIterator(it);
		while(i.hasNext()) {
			let i1 = i.next();
			a.push(i1);
		}
		return a;
	}
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				return true;
			}
		}
		return false;
	}
	static iter(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			f(x1);
		}
	}
	static filter(it,f) {
		let _g = [];
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				_g.push(x1);
			}
		}
		return _g;
	}
	static count(it,pred) {
		let n = 0;
		if(pred == null) {
			let _ = $getIterator(it);
			while(_.hasNext()) {
				let _1 = _.next();
				++n;
			}
		} else {
			let x = $getIterator(it);
			while(x.hasNext()) {
				let x1 = x.next();
				if(pred(x1)) {
					++n;
				}
			}
		}
		return n;
	}
	static find(it,f) {
		let v = $getIterator(it);
		while(v.hasNext()) {
			let v1 = v.next();
			if(f(v1)) {
				return v1;
			}
		}
		return null;
	}
	static findIndex(it,f) {
		let i = 0;
		let v = $getIterator(it);
		while(v.hasNext()) {
			let v1 = v.next();
			if(f(v1)) {
				return i;
			}
			++i;
		}
		return -1;
	}
	static concat(a,b) {
		let l = [];
		let x = $getIterator(a);
		while(x.hasNext()) {
			let x1 = x.next();
			l.push(x1);
		}
		let x1 = $getIterator(b);
		while(x1.hasNext()) {
			let x = x1.next();
			l.push(x);
		}
		return l;
	}
}
Lambda.__name__ = true;
Math.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
Std.__name__ = true;
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = true;
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
});
class StringTools {
	static htmlEscape(s,quotes) {
		let buf_b = "";
		let _g_offset = 0;
		let _g_s = s;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let code = c1;
			switch(code) {
			case 34:
				if(quotes) {
					buf_b += "&quot;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 38:
				buf_b += "&amp;";
				break;
			case 39:
				if(quotes) {
					buf_b += "&#039;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 60:
				buf_b += "&lt;";
				break;
			case 62:
				buf_b += "&gt;";
				break;
			default:
				buf_b += String.fromCodePoint(code);
			}
		}
		return buf_b;
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class UnicodeString {
	static charAt(this1,index) {
		if(index < 0) {
			return "";
		}
		let unicodeOffset = 0;
		let nativeOffset = 0;
		while(nativeOffset < this1.length) {
			let index1 = nativeOffset++;
			let c = this1.charCodeAt(index1);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | this1.charCodeAt(index1 + 1) & 1023;
			}
			let c1 = c;
			if(unicodeOffset == index) {
				return String.fromCodePoint(c1);
			}
			if(c1 >= 65536) {
				++nativeOffset;
			}
			++unicodeOffset;
		}
		return "";
	}
	static get_length(this1) {
		let l = 0;
		let _g_offset = 0;
		let _g_s = this1;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let c2 = c1;
			++l;
		}
		return l;
	}
}
class XmlType {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Element";
		case 1:
			return "PCData";
		case 2:
			return "CData";
		case 3:
			return "Comment";
		case 4:
			return "DocType";
		case 5:
			return "ProcessingInstruction";
		case 6:
			return "Document";
		}
	}
}
class Xml {
	constructor(nodeType) {
		this.nodeType = nodeType;
		this.children = [];
		this.attributeMap = new haxe_ds_StringMap();
	}
	get(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	set(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	attributes() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return haxe_ds_StringMap.keysIterator(this.attributeMap.h);
	}
	addChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	removeChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	insertChild(x,pos) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			HxOverrides.remove(x.parent.children,x);
		}
		this.children.splice(pos,0,x);
		x.parent = this;
	}
	toString() {
		return haxe_xml_Printer.print(this);
	}
	static createElement(name) {
		let xml = new Xml(Xml.Element);
		if(xml.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeName = name;
		return xml;
	}
	static createPCData(data) {
		let xml = new Xml(Xml.PCData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocument() {
		return new Xml(Xml.Document);
	}
}
Xml.__name__ = true;
Object.assign(Xml.prototype, {
	__class__: Xml
});
class database_DBMariaDB {
	static generateSQL(mld) {
		let sql = "";
		let r = haxe_ds_StringMap.valueIterator(mld.relations.h);
		while(r.hasNext()) {
			let r1 = r.next();
			let hasPK = false;
			sql += "CREATE TABLE IF NOT EXISTS " + r1.name + " (";
			let first = true;
			let _g = 0;
			let _g1 = r1.fields;
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				let fk = Lambda.find(r1.foreignKeys,function(fk) {
					return fk.name == f.name;
				});
				if(first) {
					first = false;
				} else {
					sql += ", ";
				}
				sql += f.name + " ";
				if(f.type.toUpperCase() == "COUNTER") {
					if(r1.key.length == 1 && r1.key[0] == f.name) {
						sql += "INT PRIMARY KEY AUTO_INCREMENT";
						hasPK = true;
					} else {
						sql += "INT";
					}
				} else {
					sql += f.get_dbType();
				}
				if(!hasPK && r1.key.length == 1 && r1.key[0] == f.name) {
					sql += " PRIMARY KEY";
				}
				if(fk != null) {
					sql += " REFERENCES " + fk.relation.name + "(" + fk.key + ")";
				}
			}
			if(r1.key.length != 1) {
				sql += ", PRIMARY KEY(" + r1.key.join(",") + ")";
			}
			sql += ");\n";
		}
		return sql;
	}
	static formatSQL(mld) {
		return StringTools.replace(StringTools.replace(StringTools.replace(database_DBMariaDB.generateSQL(mld),", ",",\n    ")," ("," (\n    "),");","\n);\n");
	}
}
$hx_exports["database"]["DBMariaDB"] = database_DBMariaDB;
database_DBMariaDB.__name__ = true;
class database_DBPostgreSQL {
	static generateSQL(mld) {
		let sql = "";
		let r = haxe_ds_StringMap.valueIterator(mld.relations.h);
		while(r.hasNext()) {
			let r1 = r.next();
			let hasPK = false;
			sql += "CREATE TABLE IF NOT EXISTS " + r1.name + " (";
			let first = true;
			let _g = 0;
			let _g1 = r1.fields;
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				let fk = Lambda.find(r1.foreignKeys,function(fk) {
					return fk.name == f.name;
				});
				if(first) {
					first = false;
				} else {
					sql += ", ";
				}
				sql += f.name + " ";
				if(f.type.toUpperCase() == "COUNTER") {
					if(r1.key.length == 1 && r1.key[0] == f.name) {
						sql += "SERIAL PRIMARY KEY";
						hasPK = true;
					} else {
						sql += "INT";
					}
				} else {
					sql += f.get_dbType();
				}
				if(!hasPK && r1.key.length == 1 && r1.key[0] == f.name) {
					sql += " PRIMARY KEY";
				}
				if(fk != null) {
					sql += " REFERENCES " + fk.relation.name + "(" + fk.key + ")";
				}
			}
			if(r1.key.length != 1) {
				sql += ", PRIMARY KEY(" + r1.key.join(",") + ")";
			}
			sql += ");\n";
		}
		return sql;
	}
	static formatSQL(mld) {
		return StringTools.replace(StringTools.replace(StringTools.replace(database_DBPostgreSQL.generateSQL(mld),", ",",\n    ")," ("," (\n    "),");","\n);\n");
	}
}
$hx_exports["database"]["DBPostgreSQL"] = database_DBPostgreSQL;
database_DBPostgreSQL.__name__ = true;
class database_DBSqlite {
	static generateSQL(mld) {
		let sql = "";
		let r = haxe_ds_StringMap.valueIterator(mld.relations.h);
		while(r.hasNext()) {
			let r1 = r.next();
			let hasPK = false;
			sql += "CREATE TABLE IF NOT EXISTS " + r1.name + " (";
			let first = true;
			let _g = 0;
			let _g1 = r1.fields;
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				let fk = Lambda.find(r1.foreignKeys,function(fk) {
					return fk.name == f.name;
				});
				if(first) {
					first = false;
				} else {
					sql += ", ";
				}
				sql += f.name + " ";
				if(f.type.toUpperCase() == "COUNTER") {
					if(r1.key.length == 1 && r1.key[0] == f.name) {
						sql += "INTEGER PRIMARY KEY AUTOINCREMENT";
						hasPK = true;
					} else {
						sql += "INT";
					}
				} else {
					sql += f.get_dbType();
				}
				if(!hasPK && r1.key.length == 1 && r1.key[0] == f.name) {
					sql += " PRIMARY KEY";
				}
				if(fk != null) {
					sql += " REFERENCES " + fk.relation.name + "(" + fk.key + ")";
				}
			}
			if(r1.key.length != 1) {
				sql += ", PRIMARY KEY(" + r1.key.join(",") + ")";
			}
			sql += ");\n";
		}
		return sql;
	}
	static formatSQL(mld) {
		return StringTools.replace(StringTools.replace(StringTools.replace(database_DBSqlite.generateSQL(mld),", ",",\n    ")," ("," (\n    "),");","\n);\n");
	}
}
$hx_exports["database"]["DBSqlite"] = database_DBSqlite;
database_DBSqlite.__name__ = true;
class haxe_IMap {
}
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	get_message() {
		return this.message;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	iterator() {
		return haxe_ds_StringMap.valueIterator(this.h);
	}
	static keysIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			return keys[idx - 1];
		}};
	}
	static valueIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			return h[keys[idx - 1]];
		}};
	}
}
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
class haxe_xml_Printer {
	constructor(pretty) {
		this.output = new StringBuf();
		this.pretty = pretty;
	}
	writeNode(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			let attribute = value.attributes();
			while(attribute.hasNext()) {
				let attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				let input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				let _g_current = 0;
				let _g_array = value.children;
				while(_g_current < _g_array.length) {
					let child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				let input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let commentContent = value.nodeValue;
			let _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			let input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let _g_current = 0;
			let _g_array = value.children;
			while(_g_current < _g_array.length) {
				let child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	hasChildren(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		let _g_current = 0;
		let _g_array = value.children;
		while(_g_current < _g_array.length) {
			let child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	static print(xml,pretty) {
		if(pretty == null) {
			pretty = false;
		}
		let printer = new haxe_xml_Printer(pretty);
		printer.writeNode(xml,"");
		return printer.output.b;
	}
}
haxe_xml_Printer.__name__ = true;
Object.assign(haxe_xml_Printer.prototype, {
	__class__: haxe_xml_Printer
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		if(cc == null) {
			return false;
		}
		if(cc == cl) {
			return true;
		}
		let intf = cc.__interfaces__;
		if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
			let _g = 0;
			let _g1 = intf.length;
			while(_g < _g1) {
				let i = _g++;
				let i1 = intf[i];
				if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
					return true;
				}
			}
		}
		return js_Boot.__interfLoop(cc.__super__,cl);
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __cast(o,t) {
		if(o == null || js_Boot.__instanceof(o,t)) {
			return o;
		} else {
			throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = true;
class model_Obj {
	constructor(name) {
		this.name = name;
		this.fields = [];
	}
	getField(fName) {
		return Lambda.find(this.fields,function(f) {
			return f.name == fName;
		});
	}
	getFieldIndex(fName) {
		return Lambda.findIndex(this.fields,function(f) {
			return f.name == fName;
		});
	}
	get_codeName() {
		return model_Obj.fixName(this.name);
	}
	get_className() {
		let fixedName = this.get_codeName();
		return fixedName.charAt(0).toUpperCase() + HxOverrides.substr(fixedName,1,null);
	}
	static fixName(iStr,camelCase) {
		if(camelCase == null) {
			camelCase = false;
		}
		let oStr = "";
		let toUpperCase = false;
		let _g = 0;
		let _g1 = UnicodeString.get_length(iStr);
		while(_g < _g1) {
			let i = _g++;
			let c = UnicodeString.charAt(iStr,i);
			let oStr1;
			switch(c) {
			case " ":
				if(camelCase) {
					toUpperCase = true;
					oStr1 = "";
				} else {
					oStr1 = "_";
				}
				break;
			case ".":
				oStr1 = "";
				break;
			case "À":case "Â":case "Ä":
				oStr1 = "A";
				break;
			case "Æ":
				oStr1 = "EA";
				break;
			case "Ç":
				oStr1 = "C";
				break;
			case "È":case "É":case "Ê":case "Ë":
				oStr1 = "E";
				break;
			case "Î":case "Ï":
				oStr1 = "I";
				break;
			case "Ô":case "Ö":
				oStr1 = "O";
				break;
			case "Ù":case "Û":case "Ü":
				oStr1 = "U";
				break;
			case "à":case "â":case "ä":
				oStr1 = "a";
				break;
			case "æ":
				oStr1 = "ea";
				break;
			case "ç":
				oStr1 = "c";
				break;
			case "è":case "é":case "ê":case "ë":
				oStr1 = "e";
				break;
			case "î":case "ï":
				oStr1 = "i";
				break;
			case "ô":case "ö":
				oStr1 = "o";
				break;
			case "ù":case "û":case "ü":
				oStr1 = "u";
				break;
			case "Œ":
				oStr1 = "EO";
				break;
			case "œ":
				oStr1 = "eo";
				break;
			default:
				if(toUpperCase) {
					toUpperCase = false;
					oStr1 = c.toUpperCase();
				} else {
					oStr1 = c;
				}
			}
			oStr += oStr1;
		}
		return oStr;
	}
}
model_Obj.__name__ = true;
Object.assign(model_Obj.prototype, {
	__class__: model_Obj
});
class model_Set extends model_Obj {
	constructor(name,superset,isTypedef,isInterface,isAbstract) {
		if(isAbstract == null) {
			isAbstract = false;
		}
		if(isInterface == null) {
			isInterface = false;
		}
		if(isTypedef == null) {
			isTypedef = false;
		}
		super(name);
		this.superset = superset;
		this.subsets = [];
		this.subsetType = "";
		this.subsetOption = -1;
		this.subsetCode = "";
		this.id = [];
		this.compound = null;
		this.isTypedef = isTypedef;
		this.isInterface = isInterface;
		this.isAbstract = isAbstract;
		this.interfaces = [];
		this.methods = [];
		this.accessors = [];
		this.navFields = [];
	}
}
model_Set.__name__ = true;
model_Set.__super__ = model_Obj;
Object.assign(model_Set.prototype, {
	__class__: model_Set
});
class model_Association extends model_Set {
	constructor(name) {
		super(name);
		this.links = [];
		this.isAgregation = false;
	}
	isNN() {
		return !Lambda.exists(this.links,function(l) {
			return l.max == "1";
		});
	}
	isClass() {
		return this.fields.length != 0;
	}
}
model_Association.__name__ = true;
model_Association.__super__ = model_Set;
Object.assign(model_Association.prototype, {
	__class__: model_Association
});
class model_Diagram {
	constructor() {
		this.sets = new haxe_ds_StringMap();
		this.associations = new haxe_ds_StringMap();
		this.height = 0;
		this.width = 0;
	}
	getObj(name) {
		let o = this.sets.h[name];
		if(o == null) {
			o = this.associations.h[name];
		}
		return o;
	}
	iterator() {
		return new model_ObjectsIterator(this);
	}
	getGrid() {
		let _g = [];
		let _g1 = 0;
		let _g2 = this.height;
		while(_g1 < _g2) {
			let row = _g1++;
			let _g2 = [];
			let _g3 = 0;
			let _g4 = this.width;
			while(_g3 < _g4) {
				let col = _g3++;
				_g2.push(null);
			}
			_g.push(_g2);
		}
		let grid = _g;
		let o = this.iterator();
		while(o.hasNext()) {
			let o1 = o.next();
			grid[o1.row][o1.col] = o1;
		}
		return grid;
	}
}
model_Diagram.__name__ = true;
Object.assign(model_Diagram.prototype, {
	__class__: model_Diagram
});
class model_ObjectsIterator {
	constructor(diagram) {
		let sets = Lambda.array(diagram.sets);
		let associations = Lambda.array(diagram.associations);
		this.objects = Lambda.concat(sets,associations);
		this.i = 0;
	}
	hasNext() {
		return this.i != this.objects.length;
	}
	next() {
		this.i++;
		return this.objects[this.i - 1];
	}
}
model_ObjectsIterator.__name__ = true;
Object.assign(model_ObjectsIterator.prototype, {
	__class__: model_ObjectsIterator
});
class model_Field {
	constructor(name,type,visibility,isStatic) {
		if(isStatic == null) {
			isStatic = false;
		}
		if(visibility == null) {
			visibility = 0;
		}
		this.name = name;
		this.type = type;
		this.visibility = visibility;
		this.isStatic = isStatic;
	}
	get_dbType() {
		if(this.type.toUpperCase() == "COUNTER") {
			return "INT";
		} else {
			return this.type.toUpperCase();
		}
	}
	get_codeName() {
		return model_Obj.fixName(this.name);
	}
	get_classType() {
		if(this.type.toUpperCase() == "COUNTER") {
			return "Int";
		} else {
			return model_Field.classOf(this.type);
		}
	}
	isArray() {
		return this.get_classType().substring(0,5) == "Array";
	}
	static classOf(typeName) {
		let upperName = typeName.toUpperCase();
		if(HxOverrides.substr(upperName,0,3) == "INT") {
			return "Int";
		} else if(HxOverrides.substr(upperName,0,5) == "FLOAT") {
			return "Float";
		} else if(HxOverrides.substr(upperName,0,6) == "DOUBLE") {
			return "Double";
		} else if(HxOverrides.substr(upperName,0,4) == "BOOL") {
			return "Bool";
		} else if(HxOverrides.substr(upperName,0,4) == "DATE") {
			return "Date";
		} else if(HxOverrides.substr(upperName,0,4) == "TIME") {
			return "Time";
		} else if(upperName.indexOf("CHAR") != -1) {
			return "String";
		} else {
			return typeName;
		}
	}
	static arrayOf(typeName) {
		return "Array<" + model_Field.classOf(typeName) + ">";
	}
}
model_Field.__name__ = true;
Object.assign(model_Field.prototype, {
	__class__: model_Field
});
class model_Link {
	constructor(set,role,min,max,isWeak,isAgregate,hasArrow) {
		this.set = set;
		this.role = role;
		this.min = min;
		this.max = max;
		this.isWeak = isWeak;
		this.isAgregate = isAgregate;
		this.hasArrow = hasArrow;
	}
	get_roleCode() {
		return model_Obj.fixName(this.role);
	}
}
model_Link.__name__ = true;
Object.assign(model_Link.prototype, {
	__class__: model_Link
});
class model_MLD {
	constructor() {
		this.relations = new haxe_ds_StringMap();
	}
	toString(univ) {
		if(univ == null) {
			univ = true;
		}
		let _g = [];
		let x = $getIterator(this.relations);
		while(x.hasNext()) {
			let x1 = x.next();
			_g.push(univ ? x1.toUnivString() : x1.toENString());
		}
		return _g.join("\n");
	}
}
model_MLD.__name__ = true;
Object.assign(model_MLD.prototype, {
	__class__: model_MLD
});
class model_Method extends model_Field {
	constructor(name,type,visibility,isStatic) {
		if(isStatic == null) {
			isStatic = false;
		}
		if(visibility == null) {
			visibility = 0;
		}
		super(name,type,visibility,isStatic);
		this.params = [];
	}
}
model_Method.__name__ = true;
model_Method.__super__ = model_Field;
Object.assign(model_Method.prototype, {
	__class__: model_Method
});
class model_Relation extends model_Obj {
	constructor(name) {
		super(name);
		this.key = [];
		this.foreignKeys = [];
	}
	mergeForeignKeys() {
		let mergedFKList = [];
		let i = 0;
		while(i < this.foreignKeys.length) {
			let currentFK = { names : [this.foreignKeys[i].name], relation : this.foreignKeys[i].relation, keys : [this.foreignKeys[i].key]};
			let _g = 1;
			let _g1 = currentFK.relation.key.length;
			while(_g < _g1) {
				let j = _g++;
				currentFK.names.push(this.foreignKeys[i + j].name);
				currentFK.keys.push(this.foreignKeys[i + j].key);
				++i;
			}
			++i;
			mergedFKList.push(currentFK);
		}
		return mergedFKList;
	}
	toENString() {
		let tmp = this.name + " (";
		let _this = this.fields;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].name;
		}
		let tmp1 = tmp + result.join(", ") + ")\n" + "    clé primaire : " + this.key.join(", ") + (this.foreignKeys.length == 0 ? "" : "\n");
		let _this1 = this.mergeForeignKeys();
		let result1 = new Array(_this1.length);
		let _g2 = 0;
		let _g3 = _this1.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let mfk = _this1[i];
			result1[i] = "    clé étrangère : " + mfk.names.join(", ") + " référence " + mfk.relation.name + "(" + mfk.keys.join(", ") + ")";
		}
		return tmp1 + result1.join("\n") + "\n";
	}
	toUnivString() {
		let strings = [];
		let _g = 0;
		let _g1 = this.key;
		while(_g < _g1.length) {
			let k = _g1[_g];
			++_g;
			let _g2 = [];
			let x = $getIterator(this.foreignKeys);
			while(x.hasNext()) {
				let x1 = x.next();
				_g2.push(x1.name);
			}
			strings.push("\x1B[4m" + (_g2.indexOf(k) == -1 ? "" : "#") + k + "\x1B[0m");
		}
		let _g2 = 0;
		let _g3 = this.fields;
		while(_g2 < _g3.length) {
			let f = _g3[_g2];
			++_g2;
			if(this.key.indexOf(f.name) == -1) {
				let _g = [];
				let x = $getIterator(this.foreignKeys);
				while(x.hasNext()) {
					let x1 = x.next();
					_g.push(x1.name);
				}
				strings.push((_g.indexOf(f.name) == -1 ? "" : "#") + f.name);
			}
		}
		return this.name + " (" + strings.join(", ") + ")\n";
	}
}
model_Relation.__name__ = true;
model_Relation.__super__ = model_Obj;
Object.assign(model_Relation.prototype, {
	__class__: model_Relation
});
class schema_MCDToSVG {
	static generateSVG(diagram) {
		let doc = Xml.createDocument();
		let svg = schema_Svg.initSvg(doc);
		let set = diagram.iterator();
		while(set.hasNext()) {
			let set1 = set.next();
			if(((set1) instanceof model_Association)) {
				set1.svg = schema_MCDToSVG.generateAssociationSVG(js_Boot.__cast(set1 , model_Association));
			} else if(((set1) instanceof model_Set)) {
				set1.svg = schema_MCDToSVG.generateSetSVG(js_Boot.__cast(set1 , model_Set));
			}
			svg.addChild(set1.svg);
		}
		schema_Svg.placeObjects(diagram,svg,diagram.height,diagram.width);
		schema_MCDToSVG.drawLines(diagram,svg);
		return doc;
	}
	static generateAssociationSVG(set) {
		let fieldsCount = 0;
		let chrWidth = set.name.length;
		let _g = 0;
		let _g1 = set.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			++fieldsCount;
			if(field.name.length > chrWidth) {
				chrWidth = field.name.length;
			}
		}
		let g = Xml.createElement("g");
		if(set.isAgregation) {
			let rect = Xml.createElement("rect");
			g.addChild(rect);
			rect.set("height",Std.string((fieldsCount == 0 ? 2 : fieldsCount + 1) * 16 + 10));
			rect.set("width",Std.string(chrWidth * 9.5 + 10 + 10.));
			rect.set("style","fill:white");
		}
		let rect = Xml.createElement("rect");
		g.addChild(rect);
		rect.set("height",Std.string((fieldsCount == 0 ? 2 : fieldsCount + 1) * 16 + 10));
		rect.set("width",Std.string(chrWidth * 9.5 + 10 + 10.));
		rect.set("rx","20");
		rect.set("ry","20");
		rect.set("style","fill:lightgrey");
		let line = Xml.createElement("line");
		g.addChild(line);
		line.set("x1","0");
		line.set("x2",Std.string(chrWidth * 9.5 + 10 + 10.));
		line.set("y1","21");
		line.set("y2","21");
		let title = Xml.createElement("text");
		g.addChild(title);
		title.addChild(Xml.createPCData(set.name));
		title.set("x",Std.string(10. + (chrWidth - set.name.length) * 9.5 / 2));
		title.set("y","17");
		let text = Xml.createElement("text");
		g.addChild(text);
		let _g2 = 0;
		let _g3 = set.fields.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let tspan = Xml.createElement("tspan");
			text.addChild(tspan);
			tspan.set("x",Std.string(10.));
			tspan.set("y",Std.string(16 * (i + 2) + 5));
			tspan.addChild(Xml.createPCData(set.fields[i].name));
		}
		return g;
	}
	static generateSetSVG(set) {
		let fieldsCount = 0;
		let chrWidth = set.name.length;
		let _g = 0;
		let _g1 = set.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			if(!field.isStatic) {
				++fieldsCount;
				if(field.name.length > chrWidth) {
					chrWidth = field.name.length;
				}
			}
		}
		let g = Xml.createElement("g");
		let rect = Xml.createElement("rect");
		g.addChild(rect);
		rect.set("height",Std.string((fieldsCount == 0 ? 2 : fieldsCount + 1) * 16 + 10));
		rect.set("width",Std.string(chrWidth * 9.5 + 10 | 0));
		rect.set("style","fill:white");
		let titleBG = Xml.createElement("rect");
		g.addChild(titleBG);
		titleBG.set("height","21");
		titleBG.set("width",Std.string(chrWidth * 9.5 + 10));
		titleBG.set("style","fill:lightgrey");
		let title = Xml.createElement("text");
		g.addChild(title);
		title.addChild(Xml.createPCData(set.name));
		title.set("x",Std.string(5 + (chrWidth - set.name.length) * 9.5 / 2));
		title.set("y","16");
		let text = Xml.createElement("text");
		g.addChild(text);
		let _g2 = 0;
		let _g3 = set.fields.length;
		while(_g2 < _g3) {
			let i = _g2++;
			if(!set.fields[i].isStatic) {
				let tspan = Xml.createElement("tspan");
				text.addChild(tspan);
				tspan.set("x",Std.string(2.5));
				tspan.set("y",Std.string(16 * (i + 2) + 5));
				if(set.id.indexOf(set.fields[i].name) != -1) {
					tspan.set("style","text-decoration:underline");
				}
				tspan.addChild(Xml.createPCData(set.fields[i].name));
			}
		}
		if(set.subsets.length != 0) {
			let set1 = set.subsetType;
			if(g.nodeType != Xml.Document && g.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (g.nodeType == null ? "null" : XmlType.toString(g.nodeType)));
			}
			let tmp = Std.parseInt(g.children[0].get("width"));
			if(g.nodeType != Xml.Document && g.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (g.nodeType == null ? "null" : XmlType.toString(g.nodeType)));
			}
			g.addChild(schema_MCDToSVG.generateInheritanceSVG(set1,tmp,Std.parseInt(g.children[0].get("height"))));
		}
		return g;
	}
	static generateInheritanceSVG(type,setWidth,setHeight) {
		let w = 39;
		let h = w / 2 | 0;
		let g = Xml.createElement("g");
		let line = Xml.createElement("line");
		g.addChild(line);
		line.set("x1",Std.string(w / 2 | 0));
		line.set("x2",Std.string(w / 2 | 0));
		line.set("y1","0");
		line.set("y2","5");
		let path = Xml.createElement("path");
		g.addChild(path);
		path.set("d","M " + w + " " + (h + 5) + " a1,1 0 1,0 -" + w + " 0 l " + w + " 0");
		path.set("style","fill:lightgrey");
		let title = Xml.createElement("text");
		g.addChild(title);
		title.addChild(Xml.createPCData(type));
		title.set("x",Std.string(10. + (2 - type.length) * 9.5 / 2));
		title.set("y","22");
		g.set("transform","translate(" + Std.string((setWidth - w) / 2 | 0) + "," + (setHeight == null ? "null" : "" + setHeight) + ")");
		return g;
	}
	static drawLines(diagram,svg) {
		let assoc = haxe_ds_StringMap.valueIterator(diagram.associations.h);
		while(assoc.hasNext()) {
			let assoc1 = assoc.next();
			let i = 0;
			if(assoc1.links.length == 2 && assoc1.links[0].set.name == assoc1.links[1].set.name) {
				let lt1 = assoc1.links[0].min == "X" && assoc1.links[0].max == "X" ? null : assoc1.links[0].min + "," + assoc1.links[0].max;
				svg.insertChild(schema_MCDToSVG.generateLineCardsSVG(assoc1,assoc1.links[0].set,false,assoc1.links[0].hasArrow,lt1,1,false),0);
				let lt2 = assoc1.links[1].min == "X" && assoc1.links[1].max == "X" ? null : assoc1.links[1].min + "," + assoc1.links[1].max;
				svg.insertChild(schema_MCDToSVG.generateLineCardsSVG(assoc1,assoc1.links[0].set,false,assoc1.links[1].hasArrow,lt2,-1,false),0);
				i = 2;
			}
			let _g = i;
			let _g1 = assoc1.links.length;
			while(_g < _g1) {
				let j = _g++;
				let lt = assoc1.links[j].min == "X" && assoc1.links[j].max == "X" ? null : assoc1.links[j].min + "," + assoc1.links[j].max;
				svg.insertChild(schema_MCDToSVG.generateLineCardsSVG(assoc1,assoc1.links[j].set,assoc1.links[j].isWeak,assoc1.links[j].hasArrow,lt,null,false),0);
			}
		}
		let p = haxe_ds_StringMap.valueIterator(diagram.sets.h);
		while(p.hasNext()) {
			let p1 = p.next();
			if(p1.subsets.length != 0) {
				let _g = 0;
				let _g1 = p1.subsets;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					svg.insertChild(schema_MCDToSVG.generateLineCardsSVG(p1,c,false,false,"",null,true),0);
				}
			}
		}
	}
	static generateLineCardsSVG(set1,set2,isWeak,hasArrow,cards,bend,inheritance) {
		if(bend == null) {
			bend = 0;
		}
		let _this = schema_Svg.coordRE;
		let coords1 = set1.svg.get("transform").replace(_this.r,"$1").split(",");
		let x1 = Std.parseInt(coords1[0]);
		let y1 = Std.parseInt(coords1[1]);
		let _this1 = set1.svg;
		if(_this1.nodeType != Xml.Document && _this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this1.nodeType == null ? "null" : XmlType.toString(_this1.nodeType)));
		}
		let w1 = Std.parseInt(_this1.children[0].get("width"));
		let _this2 = set1.svg;
		if(_this2.nodeType != Xml.Document && _this2.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this2.nodeType == null ? "null" : XmlType.toString(_this2.nodeType)));
		}
		let h1 = Std.parseInt(_this2.children[0].get("height"));
		let _this3 = schema_Svg.coordRE;
		let coords2 = set2.svg.get("transform").replace(_this3.r,"$1").split(",");
		let x2 = Std.parseInt(coords2[0]);
		let y2 = Std.parseInt(coords2[1]);
		let _this4 = set2.svg;
		if(_this4.nodeType != Xml.Document && _this4.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this4.nodeType == null ? "null" : XmlType.toString(_this4.nodeType)));
		}
		let w2 = Std.parseInt(_this4.children[0].get("width"));
		let _this5 = set2.svg;
		if(_this5.nodeType != Xml.Document && _this5.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this5.nodeType == null ? "null" : XmlType.toString(_this5.nodeType)));
		}
		let h2 = Std.parseInt(_this5.children[0].get("height"));
		let xl1 = x1 + (w1 / 2 | 0);
		let xl2 = x2 + (w2 / 2 | 0);
		let yl1 = y1 + (h1 / 2 | 0) + (inheritance ? h1 / 2 + 5 + 16 | 0 : 0);
		let yl2 = y2 + (h2 / 2 | 0);
		let g = Xml.createElement("g");
		g.addChild(schema_MCDToSVG.generateLineSVG(xl1,xl2,yl1,yl2,bend));
		if(cards != null) {
			g.addChild(schema_MCDToSVG.generateCardsSVG(x2,y2,w2,h2,xl1,xl2,yl1,yl2,bend,cards,isWeak));
		}
		if(hasArrow) {
			g.addChild(schema_MCDToSVG.generateArrowSVG(x2,y2,w2,h2,xl1,yl1,xl2,yl2,bend));
		}
		return g;
	}
	static generateArrowSVG(x2,y2,w2,h2,xl1,yl1,xl2,yl2,bend) {
		let x;
		let y;
		let rot;
		if(yl1 == yl2) {
			x = x2 + (xl1 > xl2 ? w2 : 0);
			y = yl2;
			rot = xl1 < xl2 ? 0 : 180;
		} else if(xl1 == xl2) {
			x = xl2;
			y = y2 + (yl1 > yl2 ? h2 : 0);
			rot = yl1 < yl2 ? 90 : -90;
		} else {
			let steering = (yl2 - yl1) / (xl2 - xl1);
			let offset = yl2 - steering * xl2;
			x = Math.round((y2 + (yl2 < yl1 ? h2 : 0) - offset) / steering);
			y = Math.round((x2 + (xl2 < xl1 ? w2 : 0)) * steering + offset);
			if(y >= y2 && y <= y2 + h2) {
				x = xl2 > xl1 ? xl2 : xl2 + w2;
			} else {
				y = yl2 > yl1 ? y2 : y2 + h2;
			}
			rot = Math.atan(steering) / (Math.PI * 2) * 360;
		}
		if(bend != 0) {
			let xlm = (xl2 + xl1) / 2 | 0;
			let ylm = (yl2 + yl1) / 2 | 0;
			x = xlm - (ylm - yl1) * bend / 2 | 0;
			y = ylm + (xlm - xl1) * bend / 2 | 0;
			rot = (rot + 180) % 360;
		}
		let arrow = Xml.createElement("path");
		arrow.set("d","M " + x + " " + y + " l -" + 5 + " " + 5 + " v -" + 10);
		arrow.set("transform","rotate(" + rot + ", " + x + ", " + y + ")");
		arrow.set("style","fill:black;stroke:black");
		return arrow;
	}
	static generateCardsSVG(x2,y2,w2,h2,xl1,xl2,yl1,yl2,bend,cards,isWeak) {
		let mm = Xml.createElement("text");
		mm.addChild(Xml.createPCData(cards));
		if(isWeak) {
			mm.set("style","text-decoration:underline");
		}
		let xc;
		let yc;
		if(Math.abs(xl1 - xl2) > 40 && Math.abs(yl1 - yl2) > 40 && bend != 0) {
			let xlm = (xl2 + xl1) / 2 | 0;
			let ylm = (yl2 + yl1) / 2 | 0;
			xc = xlm - (ylm - yl1) * bend / 2 | 0;
			yc = ylm + (xlm - xl1) * bend / 2 | 0;
			xc += 9.5 * (xc > xlm ? -2 : -1) | 0;
			yc += 16 * (yc > ylm ? -1 : 1.5) | 0;
		} else {
			if(Math.abs(xl1 - xl2) <= 40) {
				let dx = (bend == 0 ? 0 : bend == 1 ? -40. : 7.) | 0;
				xc = x2 + ((5 + w2) / 2 | 0) + dx;
			} else if(xl1 < xl2) {
				xc = x2 - 28.5 - 2 | 0;
			} else {
				xc = x2 + w2 + 2;
			}
			if(Math.abs(yl1 - yl2) <= 40) {
				let dy = (bend == 0 ? 0 : bend == -1 ? -37 : 16) | 0;
				yc = y2 + (h2 / 2 | 0) + 16 + dy;
			} else if(yl1 < yl2) {
				yc = y2 - 5;
			} else {
				yc = y2 + h2 + 16;
			}
		}
		mm.set("x",xc == null ? "null" : "" + xc);
		mm.set("y",yc == null ? "null" : "" + yc);
		return mm;
	}
	static generateLineSVG(xl1,xl2,yl1,yl2,bend) {
		let line;
		if(bend == 0) {
			line = Xml.createElement("line");
			line.set("x1",xl1 == null ? "null" : "" + xl1);
			line.set("x2",xl2 == null ? "null" : "" + xl2);
			line.set("y1",yl1 == null ? "null" : "" + yl1);
			line.set("y2",yl2 == null ? "null" : "" + yl2);
		} else {
			line = Xml.createElement("path");
			let xlm = (xl2 + xl1) / 2 | 0;
			let ylm = (yl2 + yl1) / 2 | 0;
			let xlq = xlm - (ylm - yl1) * bend | 0;
			let ylq = ylm + (xlm - xl1) * bend | 0;
			line.set("d","M " + xl1 + " " + yl1 + " Q " + xlq + " " + ylq + " " + xl2 + " " + yl2);
		}
		return line;
	}
}
$hx_exports["schema"]["MCDToSVG"] = schema_MCDToSVG;
schema_MCDToSVG.__name__ = true;
class schema_MLDToSVG {
	static generateSVG(mld,typed) {
		let doc = Xml.createDocument();
		let svg = schema_Svg.initSvg(doc);
		let relation = haxe_ds_StringMap.valueIterator(mld.relations.h);
		while(relation.hasNext()) {
			let relation1 = relation.next();
			relation1.svg = schema_MLDToSVG.generateTableSvg(relation1,typed);
			svg.addChild(relation1.svg);
		}
		schema_Svg.placeObjects(mld.relations,svg,mld.height,mld.width);
		let relation1 = haxe_ds_StringMap.valueIterator(mld.relations.h);
		while(relation1.hasNext()) {
			let relation = relation1.next();
			let _g = 0;
			let _g1 = relation.foreignKeys;
			while(_g < _g1.length) {
				let fk = _g1[_g];
				++_g;
				svg.addChild(schema_MLDToSVG.generateLineSVG(relation,fk));
			}
		}
		return doc;
	}
	static generateTableSvg(relation,typed) {
		let chrWidth = relation.name.length;
		let _g = 0;
		let _g1 = relation.fields;
		while(_g < _g1.length) {
			let field = _g1[_g];
			++_g;
			let lineWidth = field.name.length + (typed ? field.get_dbType().length + 2 : 0);
			if(lineWidth > chrWidth) {
				chrWidth = lineWidth;
			}
		}
		let g = Xml.createElement("g");
		let rect = Xml.createElement("rect");
		g.addChild(rect);
		rect.set("height",Std.string((relation.fields.length + 1) * 16 + 10));
		rect.set("width",Std.string(chrWidth * 9.5 + 10 | 0));
		rect.set("style","fill:white");
		let titleBG = Xml.createElement("rect");
		g.addChild(titleBG);
		titleBG.set("height","21");
		titleBG.set("width",Std.string(chrWidth * 9.5 + 10));
		titleBG.set("style","fill:lightgrey");
		let title = Xml.createElement("text");
		g.addChild(title);
		title.addChild(Xml.createPCData(relation.name));
		title.set("x",Std.string(5 + (chrWidth - relation.name.length) * 9.5 / 2));
		title.set("y","16");
		let text = Xml.createElement("text");
		g.addChild(text);
		let _g2 = 0;
		let _g3 = relation.fields.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let tspan = Xml.createElement("tspan");
			text.addChild(tspan);
			tspan.set("x",Std.string(2.5));
			tspan.set("y",Std.string(16 * (i + 2) + 5));
			if(relation.key.indexOf(relation.fields[i].name) != -1) {
				tspan.set("style","text-decoration:underline");
			}
			tspan.addChild(Xml.createPCData(relation.fields[i].name));
			if(typed) {
				tspan = Xml.createElement("tspan");
				text.addChild(tspan);
				tspan.set("x",Std.string(5 + (chrWidth - relation.fields[i].get_dbType().length) * 9.5));
				tspan.set("y",Std.string(16 * (i + 2) + 5));
				tspan.addChild(Xml.createPCData(relation.fields[i].get_dbType()));
			}
		}
		return g;
	}
	static generateLineSVG(relation,fk) {
		let _this = schema_Svg.coordRE;
		let coords1 = relation.svg.get("transform").replace(_this.r,"$1").split(",");
		let x1 = Std.parseInt(coords1[0]);
		let y1 = Std.parseInt(coords1[1]);
		let _this1 = relation.svg;
		if(_this1.nodeType != Xml.Document && _this1.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this1.nodeType == null ? "null" : XmlType.toString(_this1.nodeType)));
		}
		let w1 = Std.parseInt(_this1.children[0].get("width"));
		let _this2 = schema_Svg.coordRE;
		let coords2 = fk.relation.svg.get("transform").replace(_this2.r,"$1").split(",");
		let x2 = Std.parseInt(coords2[0]);
		let y2 = Std.parseInt(coords2[1]);
		let _this3 = fk.relation.svg;
		if(_this3.nodeType != Xml.Document && _this3.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this3.nodeType == null ? "null" : XmlType.toString(_this3.nodeType)));
		}
		let w2 = Std.parseInt(_this3.children[0].get("width"));
		y1 += 16 * (relation.getFieldIndex(fk.name) + 2);
		y2 += 16 * (fk.relation.getFieldIndex(fk.key) + 2);
		let xl1;
		let xl2;
		let xa = 5;
		if(relation.col == fk.relation.col) {
			x1 += w1;
			x2 += w2;
			xl1 = (Math.max(x1,x2) | 0) + 10;
			xl2 = xl1;
		} else if(relation.col < fk.relation.col) {
			x1 += w1;
			xl1 = x1 + 10;
			xl2 = x2 - 10;
			xa = -xa;
		} else {
			x2 += w2;
			xl1 = x1 - 10;
			xl2 = x2 + 10;
		}
		let g = Xml.createElement("g");
		let line = Xml.createElement("path");
		line.set("d","M " + x1 + " " + y1 + " L " + xl1 + " " + y1 + " L " + xl2 + " " + y2 + " L " + x2 + " " + y2);
		g.addChild(line);
		let arrow = Xml.createElement("path");
		arrow.set("d","M " + x2 + " " + y2 + " l " + xa + " " + 5 + " v -" + 10);
		arrow.set("style","fill:black;stroke:black");
		g.addChild(arrow);
		return g;
	}
}
$hx_exports["schema"]["MLDToSVG"] = schema_MLDToSVG;
schema_MLDToSVG.__name__ = true;
class schema_Svg {
	static initSvg(doc) {
		let svg = Xml.createElement("svg");
		doc.addChild(svg);
		svg.set("xmlns","http://www.w3.org/2000/svg");
		let defs = Xml.createElement("defs");
		svg.addChild(defs);
		let fontStyle = Xml.createElement("style");
		defs.addChild(fontStyle);
		fontStyle.addChild(Xml.createPCData("@import url('https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap')"));
		let css = Xml.createElement("style");
		defs.addChild(css);
		css.addChild(Xml.createPCData("text,text>tspan{" + "font-family:'Roboto Mono';font-size:16px" + "} rect{" + "stroke:black" + "} line,path{" + "fill:none;stroke:black" + "}"));
		return svg;
	}
	static placeObjects(objects,svg,height,width) {
		let _g = [];
		let _g1 = 0;
		let _g2 = height;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(0);
		}
		let heights = _g;
		let _g3 = [];
		let _g4 = 0;
		let _g5 = width;
		while(_g4 < _g5) {
			let i = _g4++;
			_g3.push(0);
		}
		let widths = _g3;
		let o = $getIterator(objects);
		while(o.hasNext()) {
			let o1 = o.next();
			let _this = o1.svg;
			if(_this.nodeType != Xml.Document && _this.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
			}
			let w = Std.parseInt(_this.children[0].get("width"));
			let _this1 = o1.svg;
			if(_this1.nodeType != Xml.Document && _this1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this1.nodeType == null ? "null" : XmlType.toString(_this1.nodeType)));
			}
			let h = Std.parseInt(_this1.children[0].get("height"));
			if(w > widths[o1.col]) {
				widths[o1.col] = w;
			}
			if(h > heights[o1.row]) {
				heights[o1.row] = h;
			}
		}
		let th = 20;
		let lineOffsets = [];
		let _g6 = 0;
		let _g7 = height;
		while(_g6 < _g7) {
			let i = _g6++;
			lineOffsets[i] = th;
			th = th + heights[i] + 40;
		}
		let tw = 20;
		let columnOffsets = [];
		let _g8 = 0;
		let _g9 = width;
		while(_g8 < _g9) {
			let i = _g8++;
			columnOffsets[i] = tw;
			tw = tw + widths[i] + 40;
		}
		let o1 = $getIterator(objects);
		while(o1.hasNext()) {
			let o = o1.next();
			let columnOffsets1 = columnOffsets[o.col];
			let widths1 = widths[o.col];
			let _this = o.svg;
			if(_this.nodeType != Xml.Document && _this.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
			}
			let w = columnOffsets1 + (widths1 - Std.parseInt(_this.children[0].get("width"))) / 2 | 0;
			let lineOffsets1 = lineOffsets[o.row];
			let heights1 = heights[o.row];
			let _this1 = o.svg;
			if(_this1.nodeType != Xml.Document && _this1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (_this1.nodeType == null ? "null" : XmlType.toString(_this1.nodeType)));
			}
			let h = lineOffsets1 + (heights1 - Std.parseInt(_this1.children[0].get("height"))) / 2 | 0;
			o.svg.set("transform","translate(" + w + "," + h + ")");
		}
		svg.set("width",Std.string(tw - 20));
		svg.set("height",Std.string(th - 20));
	}
}
schema_Svg.__name__ = true;
class source_Mocodo {
	static load(mocodoText) {
		let lines = mocodoText.split("\n");
		let diagram = new model_Diagram();
		try {
			source_Mocodo.loadSets(diagram,lines);
			source_Mocodo.loadAssociations(diagram,lines);
			source_Mocodo.loadSubsets(diagram,lines);
			source_Mocodo.loadMethods(diagram,lines);
			source_Mocodo.loadLayout(diagram,lines);
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			if(typeof(_g1.unwrap()) == "string") {
				diagram = null;
			} else {
				let e = _g1;
				$global.console.log(e.get_message());
			}
		}
		if(diagram != null && !haxe_ds_StringMap.valueIterator(diagram.sets.h).hasNext()) {
			diagram = null;
		}
		return diagram;
	}
	static loadAssociations(diagram,lines) {
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let lineIndex = _g++;
			let line = lines[lineIndex];
			if(source_Mocodo.associationRE.match(line)) {
				let name = StringTools.trim(line.substring(0,line.indexOf(",")));
				let assoc = new model_Association(name);
				let posColumn = line.indexOf(":");
				if(posColumn == -1) {
					posColumn = line.length;
				}
				let links = line.substring(line.indexOf(",") + 1,posColumn).split(",");
				source_Mocodo.loadAssociationLinks(diagram,lineIndex,assoc,links);
				if(posColumn != line.length) {
					let fields = line.substring(posColumn + 1).split(",");
					let _g = 0;
					let _g1 = fields.length;
					while(_g < _g1) {
						let i = _g++;
						source_Mocodo.loadField(assoc,null,StringTools.trim(fields[i]));
					}
				}
				diagram.associations.h[name] = assoc;
			}
		}
	}
	static loadAssociationLinks(diagram,lineIndex,assoc,links) {
		let compoundSet = null;
		let componentSet = null;
		let _g = 0;
		let _g1 = links.length;
		while(_g < _g1) {
			let i = _g++;
			let link = StringTools.trim(links[i]);
			let setName = StringTools.trim(link.replace(source_Mocodo.linkRE.r,"$3"));
			let isWeak = false;
			let isAgregate = false;
			let hasArrow = false;
			let linkToAssoc = false;
			let set = diagram.sets.h[setName];
			if(set == null) {
				set = diagram.associations.h[setName];
				linkToAssoc = true;
			}
			if(set != null) {
				if(linkToAssoc) {
					(js_Boot.__cast(set , model_Association)).isAgregation = true;
				}
				if(link.charAt(0) == "_") {
					link = link.substring(1);
					componentSet = set;
					isWeak = true;
				} else {
					compoundSet = set;
					if(link.charAt(0) == "-") {
						link = link.substring(1);
						isAgregate = true;
					}
				}
				if(link.charAt(2) == ">") {
					hasArrow = true;
				}
				let role = link.replace(source_Mocodo.linkRE.r,"$2");
				let min = link.charAt(0);
				let max = link.charAt(1);
				assoc.links.push(new model_Link(set,role,min,max,isWeak,isAgregate,hasArrow));
			}
		}
		if(componentSet != null) {
			componentSet.compound = compoundSet;
		}
	}
	static loadSets(diagram,lines) {
		let _g = 0;
		while(_g < lines.length) {
			let line = lines[_g];
			++_g;
			if(source_Mocodo.entityRE.match(line)) {
				let name = StringTools.trim(line.substring(0,line.indexOf(":")));
				let isInterface = false;
				let set = new model_Set(name,null,false,isInterface);
				let lineSubStr = StringTools.trim(line.substring(line.indexOf(":") + 1));
				if(lineSubStr != "") {
					let fields = lineSubStr.split(",");
					let _g = 0;
					let _g1 = fields.length;
					while(_g < _g1) {
						let i = _g++;
						source_Mocodo.loadField(set,i,StringTools.trim(fields[i]));
					}
				}
				diagram.sets.h[name] = set;
			}
		}
	}
	static loadField(set,fieldIndex,name) {
		if(fieldIndex == null) {
			fieldIndex = -1;
		}
		let type = source_Mocodo.DEFAULT_TYPE;
		let visibility = model_Field.ACCESS_UNSET;
		let isStatic = false;
		let idSwap = false;
		if(source_Mocodo.typeRE.match(name)) {
			type = StringTools.trim(name.replace(source_Mocodo.typeRE.r,"$2"));
			name = StringTools.trim(name.replace(source_Mocodo.typeRE.r,"$1"));
		}
		let firstChar = name.charAt(0);
		while(firstChar == "_" || firstChar == "~" || firstChar == "-" || firstChar == "+" || firstChar == "#") {
			switch(firstChar) {
			case "#":
				visibility = model_Field.ACCESS_PROTECTED;
				break;
			case "+":
				visibility = model_Field.ACCESS_PUBLIC;
				break;
			case "-":
				visibility = model_Field.ACCESS_PRIVATE;
				break;
			case "_":
				idSwap = true;
				break;
			case "~":
				isStatic = true;
				break;
			}
			name = HxOverrides.substr(name,1,null);
			firstChar = name.charAt(0);
		}
		if(!((set) instanceof model_Association)) {
			if(fieldIndex == 0 && !idSwap || fieldIndex != 0 && idSwap) {
				set.id.push(name);
			}
		}
		set.fields.push(new model_Field(name,type,visibility,isStatic));
	}
	static loadSubsets(diagram,lines) {
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let lineIndex = _g++;
			let line = lines[lineIndex];
			if(source_Mocodo.legacySubsetRE.match(line)) {
				let type = line.replace(source_Mocodo.legacySubsetRE.r,"$4");
				let supersetName = StringTools.trim(line.replace(source_Mocodo.legacySubsetRE.r,"$5"));
				let superset = diagram.sets.h[supersetName];
				if(superset != null) {
					superset.subsetType = type;
					if(type == "XT" || type == "P") {
						superset.isAbstract = true;
					}
					let children = line.replace(source_Mocodo.legacySubsetRE.r,"$1").split(" U ");
					let _g = 0;
					let _g1 = children.length;
					while(_g < _g1) {
						let i = _g++;
						let childName = StringTools.trim(children[i]);
						let child = diagram.sets.h[childName];
						if(child != null) {
							superset.subsets.push(child);
							child.id = [];
							child.superset = superset;
						}
					}
				}
			} else if(source_Mocodo.subsetRE.match(line)) {
				let type = line.replace(source_Mocodo.subsetRE.r,"$1");
				let supersetName = StringTools.rtrim(line.replace(source_Mocodo.subsetRE.r,"$2"));
				let superset = diagram.sets.h[supersetName];
				if(superset != null) {
					superset.subsetType = type;
					let tmp;
					switch(line.replace(source_Mocodo.subsetRE.r,"$3")) {
					case "-":
						tmp = model_Set.SUBSET_OPT_BOTH;
						break;
					case "<":
						tmp = model_Set.SUBSET_OPT_PARENT;
						break;
					case ">":
						tmp = model_Set.SUBSET_OPT_CHILDREN;
						break;
					default:
						tmp = -1;
					}
					superset.subsetOption = tmp;
					if(type == "XT" || type == "P") {
						superset.isAbstract = true;
					}
					let codeType = line.replace(source_Mocodo.subsetRE.r,"$4");
					if(codeType != "") {
						superset.subsetCode = HxOverrides.substr(codeType,1,codeType.length - 2);
					}
					let children = line.replace(source_Mocodo.subsetRE.r,"$5").split(",");
					let _g = 0;
					let _g1 = children.length;
					while(_g < _g1) {
						let i = _g++;
						let childName = StringTools.trim(children[i]);
						let child = diagram.sets.h[childName];
						if(child != null) {
							superset.subsets.push(child);
							child.superset = superset;
						}
					}
				}
			}
		}
	}
	static loadMethods(diagram,lines) {
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let l = _g++;
			let line = lines[l];
			if(source_Mocodo.methodRE.match(line)) {
				let className = StringTools.trim(line.substring(0,line.indexOf(":") - 2));
				let set = diagram.sets.h[className];
				if(set == null) {
					set = new model_Set(className,null,false,true,true);
					diagram.sets.h[className] = set;
				}
				let lineSubStr = line.substring(line.indexOf(":") + 1);
				let start = 0;
				let end = lineSubStr.indexOf(")",start);
				while(end != -1) {
					let next = lineSubStr.indexOf(",",end);
					let methodStr;
					if(next != -1) {
						methodStr = lineSubStr.substring(start,next);
						start = next + 1;
						end = lineSubStr.indexOf(")",start);
					} else {
						methodStr = lineSubStr.substring(start);
						end = -1;
					}
					source_Mocodo.loadMethod(set,StringTools.trim(methodStr));
				}
			}
		}
	}
	static loadMethod(set,methodStr) {
		let visibility = model_Field.ACCESS_PUBLIC;
		let isStatic = false;
		let name = StringTools.trim(methodStr.substring(0,methodStr.indexOf("(")));
		let type = methodStr.substring(methodStr.indexOf(")") + 1);
		type = StringTools.trim(type.substring(type.indexOf("[") + 1,type.indexOf("]")));
		let firstChar = name.charAt(0);
		while(firstChar == "~" || firstChar == "-" || firstChar == "+" || firstChar == "#") {
			switch(firstChar) {
			case "#":
				visibility = model_Field.ACCESS_PROTECTED;
				break;
			case "+":
				visibility = model_Field.ACCESS_PUBLIC;
				break;
			case "-":
				visibility = model_Field.ACCESS_PRIVATE;
				break;
			case "~":
				isStatic = true;
				break;
			}
			name = HxOverrides.substr(name,1,null);
			firstChar = name.charAt(0);
		}
		if(name == "") {
			name = set.name;
		}
		let method = new model_Method(name,type,visibility,isStatic);
		let paramsStr = StringTools.trim(methodStr.substring(methodStr.indexOf("(") + 1,methodStr.indexOf(")")));
		if(paramsStr != "") {
			source_Mocodo.loadParams(set,method,paramsStr);
		}
		set.methods.push(method);
	}
	static loadParams(set,method,paramsStr) {
		let _g = 0;
		let _g1 = paramsStr.split(",");
		while(_g < _g1.length) {
			let paramSubStr = _g1[_g];
			++_g;
			let name = StringTools.trim(paramSubStr);
			let type = "";
			if(paramSubStr.indexOf("[") != -1) {
				name = StringTools.trim(paramSubStr.substring(0,paramSubStr.indexOf("[")));
				if(paramSubStr.indexOf("]",paramSubStr.indexOf("[")) != -1) {
					type = StringTools.trim(paramSubStr.substring(paramSubStr.indexOf("[") + 1,paramSubStr.indexOf("]")));
				}
			}
			if(type == "") {
				let field = set.getField(name);
				if(field != null) {
					type = field.get_dbType();
				} else {
					type = source_Mocodo.DEFAULT_TYPE;
				}
			}
			method.params.push(new model_Field(name,type));
		}
	}
	static loadLayout(diagram,lines) {
		let maxCol = 0;
		let col = 0;
		let row = 0;
		let _g = 0;
		while(_g < lines.length) {
			let line = lines[_g];
			++_g;
			if(StringTools.trim(line) == "") {
				if(col != 0) {
					if(col > maxCol) {
						maxCol = col;
					}
					col = 0;
					++row;
				}
			} else {
				let set = null;
				if(StringTools.trim(line) == ":") {
					++col;
				} else if(source_Mocodo.entityRE.match(line)) {
					let _this = diagram.sets;
					let key = StringTools.trim(line.substring(0,line.indexOf(":")));
					set = _this.h[key];
					set.row = row;
					set.col = col;
					++col;
				} else if(source_Mocodo.associationRE.match(line)) {
					let _this = diagram.associations;
					let key = StringTools.trim(line.substring(0,line.indexOf(",")));
					set = _this.h[key];
					set.row = row;
					set.col = col;
					++col;
				}
			}
		}
		diagram.height = row + 1;
		diagram.width = maxCol;
	}
	static save(diagram) {
		let mocodoText = "";
		let grid = diagram.getGrid();
		let _g = 0;
		let _g1 = grid.length;
		while(_g < _g1) {
			let lineIndex = _g++;
			let _g1 = 0;
			let _g2 = grid[lineIndex];
			while(_g1 < _g2.length) {
				let set = _g2[_g1];
				++_g1;
				if(set == null) {
					mocodoText += ":";
				} else if(((set) instanceof model_Association)) {
					mocodoText += source_Mocodo.saveAssociation(js_Boot.__cast(set , model_Association));
				} else {
					mocodoText += source_Mocodo.saveSet(set);
				}
				mocodoText += "\n";
			}
			if(lineIndex != grid.length - 1) {
				mocodoText += "\n";
			}
		}
		return mocodoText;
	}
	static saveAssociation(assoc) {
		let mocodoText = assoc.name;
		let _g = 0;
		let _g1 = assoc.links;
		while(_g < _g1.length) {
			let link = _g1[_g];
			++_g;
			mocodoText += ", " + (link.isWeak ? "_" : "") + link.min + link.max + " " + link.set.name;
		}
		let _g2 = 0;
		let _g3 = assoc.fields.length;
		while(_g2 < _g3) {
			let fieldIndex = _g2++;
			if(fieldIndex != 0) {
				mocodoText += ", ";
			} else {
				mocodoText += ": ";
			}
			mocodoText += assoc.fields[fieldIndex].name + " [" + assoc.fields[fieldIndex].type + "]";
		}
		return mocodoText;
	}
	static saveSet(set) {
		let mocodoText = set.name + ": ";
		let _g = [];
		let x = $getIterator(set.fields);
		while(x.hasNext()) {
			let x1 = x.next();
			_g.push(x1.name + " [" + x1.type + "]");
		}
		mocodoText += "_" + _g.join(", ");
		if(set.subsets.length != 0) {
			let mocodoText1 = "\n/\\ " + set.name + " - ";
			let _g = [];
			let x = $getIterator(set.subsets);
			while(x.hasNext()) {
				let x1 = x.next();
				_g.push(x1.name);
			}
			mocodoText += mocodoText1 + _g.join(", ");
		}
		return mocodoText;
	}
}
$hx_exports["source"]["Mocodo"] = source_Mocodo;
source_Mocodo.__name__ = true;
class transform_DiagramToMLD {
	static transform(diagram) {
		let mld = new model_MLD();
		transform_DiagramToMLD.setsToRelations(diagram,mld);
		transform_DiagramToMLD.subsetsToRelations(diagram,mld);
		transform_DiagramToMLD.componentsToRelations(diagram,mld);
		transform_DiagramToMLD.associationsToRelations(diagram,mld);
		transform_DiagramToMLD.supersetToChildren(diagram,mld);
		transform_DiagramToMLD.subsetsToParent(diagram,mld);
		transform_DiagramToMLD.copyLayout(diagram,mld);
		let unneeded = [];
		Lambda.iter(mld.relations,function(r) {
			if(r.foreignKeys.length != r.key.length && r.key.length == r.fields.length) {
				unneeded.push(r.name);
			}
		});
		Lambda.iter(unneeded,function(rName) {
			let _this = mld.relations;
			if(Object.prototype.hasOwnProperty.call(_this.h,rName)) {
				delete(_this.h[rName]);
			}
		});
		let _g = 0;
		while(_g < unneeded.length) {
			let rName = unneeded[_g];
			++_g;
			Lambda.iter(mld.relations,function(r) {
				r.foreignKeys = Lambda.filter(r.foreignKeys,function(fk) {
					return fk.relation.name != rName;
				});
			});
		}
		return mld;
	}
	static setsToRelations(diagram,mld) {
		let e = haxe_ds_StringMap.valueIterator(diagram.sets.h);
		while(e.hasNext()) {
			let e1 = e.next();
			let eName = e1.get_codeName();
			let r = new model_Relation(eName);
			let _g = 0;
			let _g1 = e1.fields;
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				let fName = f.get_codeName();
				if(!f.isStatic) {
					r.fields.push(new model_Field(fName,f.type));
					if(e1.id.indexOf(f.name) != -1) {
						r.key.push(fName);
					}
				}
			}
			mld.relations.h[eName] = r;
		}
	}
	static subsetsToRelations(diagram,mld) {
		let e = haxe_ds_StringMap.valueIterator(diagram.sets.h);
		while(e.hasNext()) {
			let e1 = e.next();
			if(e1.superset != null) {
				let _this = mld.relations;
				let key = e1.get_codeName();
				let r = _this.h[key];
				let _this1 = mld.relations;
				let key1 = e1.superset.get_codeName();
				let pr = _this1.h[key1];
				let hasProperKey = r.key.length != 0;
				let pos = 0;
				let _g = 0;
				let _g1 = pr.key;
				while(_g < _g1.length) {
					let fName = _g1[_g];
					++_g;
					if(!hasProperKey) {
						r.key.push(fName);
					}
					let pField = pr.getField(fName);
					let _this = r.fields;
					let x = new model_Field(fName,pField.get_dbType());
					_this.splice(pos,0,x);
					++pos;
					r.foreignKeys.push({ name : fName, relation : pr, key : fName});
				}
			}
		}
	}
	static componentsToRelations(diagram,mld) {
		let e = haxe_ds_StringMap.valueIterator(diagram.sets.h);
		while(e.hasNext()) {
			let e1 = e.next();
			if(e1.compound != null) {
				let _this = mld.relations;
				let key = e1.get_codeName();
				let r = _this.h[key];
				let pos = 0;
				let _this1 = mld.relations;
				let key1 = e1.compound.get_codeName();
				let cr = _this1.h[key1];
				let _g = 0;
				let _g1 = cr.key;
				while(_g < _g1.length) {
					let fName = _g1[_g];
					++_g;
					r.key.splice(pos,0,fName);
					let cField = cr.getField(fName);
					let cType = cField.get_dbType();
					let _this = r.fields;
					let x = new model_Field(fName,cType);
					_this.splice(pos,0,x);
					r.foreignKeys.push({ name : fName, relation : cr, key : fName});
					++pos;
				}
			}
		}
	}
	static associationsToRelations(diagram,mld) {
		let associations = [];
		let a = haxe_ds_StringMap.valueIterator(diagram.associations.h);
		while(a.hasNext()) {
			let a1 = a.next();
			associations.push(a1);
		}
		while(associations.length != 0) {
			let a = associations.pop();
			if(Lambda.exists(a.links,function(l) {
				let _this = mld.relations;
				let key = l.set.get_codeName();
				return _this.h[key] == null;
			})) {
				associations.splice(0,0,a);
				continue;
			}
			if(!a.isNN()) {
				transform_DiagramToMLD.association1NtoRelation(diagram,mld,a);
			} else {
				transform_DiagramToMLD.associationNNtoRelation(diagram,mld,a);
			}
		}
	}
	static association1NtoRelation(diagram,mld,a) {
		let l1 = null;
		let ln = null;
		let _g = 0;
		let _g1 = a.links;
		while(_g < _g1.length) {
			let l = _g1[_g];
			++_g;
			if(l.max == "1") {
				if(l1 == null) {
					l1 = l;
				} else if(l.min == "1") {
					ln = l1;
					l1 = l;
				} else {
					ln = l;
				}
			} else {
				ln = l;
			}
		}
		if(l1 != null && ln != null) {
			let _this = mld.relations;
			let key = l1.set.get_codeName();
			let r1 = _this.h[key];
			if(!l1.isWeak) {
				transform_DiagramToMLD.addForeignKey(diagram,mld,ln,r1,false);
			}
		}
	}
	static associationNNtoRelation(diagram,mld,a) {
		let r = new model_Relation(a.get_codeName());
		let _g = 0;
		let _g1 = a.links;
		while(_g < _g1.length) {
			let l = _g1[_g];
			++_g;
			transform_DiagramToMLD.addForeignKey(diagram,mld,l,r,true);
		}
		let _g2 = 0;
		let _g3 = a.fields;
		while(_g2 < _g3.length) {
			let f = _g3[_g2];
			++_g2;
			if(!f.isStatic) {
				r.fields.push(new model_Field(f.get_codeName(),f.type));
			}
		}
		let _this = mld.relations;
		let key = a.get_codeName();
		_this.h[key] = r;
	}
	static addForeignKey(diagram,mld,l,r,pk) {
		let _this = mld.relations;
		let key = l.set.get_codeName();
		let rl = _this.h[key];
		if(rl == null) {
			let _this = mld.relations;
			let key = l.set.superset.get_codeName();
			rl = _this.h[key];
		}
		let _g = 0;
		let _g1 = rl.key;
		while(_g < _g1.length) {
			let k = _g1[_g];
			++_g;
			let fName = transform_DiagramToMLD.constructFieldName(r,k,l.get_roleCode(),rl.get_codeName(),rl.key.length == 1);
			let rField = rl.getField(k);
			let fType = rField.get_dbType();
			r.fields.push(new model_Field(fName,fType));
			r.foreignKeys.push({ name : fName, relation : rl, key : k});
			if(pk) {
				r.key.push(fName);
			}
		}
	}
	static constructFieldName(r,k,role,rName,isSingleField) {
		let fName = "";
		if(role != "") {
			if(isSingleField) {
				fName = role;
			} else {
				fName = k + (HxOverrides.cca(k,k.length - 1) >= 97 && HxOverrides.cca(role,0) <= 90 ? role.charAt(0).toUpperCase() + role.substring(1) : "_" + role);
			}
		} else {
			let _this = r.fields;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this[i].name;
			}
			let usedFields = result;
			if(usedFields.indexOf(k) == -1) {
				fName = k;
			} else {
				fName = k + (HxOverrides.cca(k,k.length - 1) >= 97 && HxOverrides.cca(rName,0) <= 90 ? rName.charAt(0).toUpperCase() + rName.substring(1) : "_" + rName);
			}
			while(usedFields.indexOf(fName) != -1) fName += "1";
		}
		return fName;
	}
	static subsetsToParent(diagram,mld) {
		let e = haxe_ds_StringMap.valueIterator(diagram.sets.h);
		while(e.hasNext()) {
			let e1 = e.next();
			if(e1.subsetOption == model_Set.SUBSET_OPT_PARENT) {
				let _this = mld.relations;
				let key = e1.get_codeName();
				let pr = _this.h[key];
				if(e1.subsetCode != "") {
					pr.fields.push(new model_Field(e1.subsetCode,"INT"));
				}
				let _g = 0;
				let _g1 = e1.subsets;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					let _this = mld.relations;
					let key = c.get_codeName();
					let cr = _this.h[key];
					Lambda.iter(cr.fields,function(f) {
						if(pr.key.indexOf(f.name) == -1) {
							pr.fields.push(f);
						}
					});
					Lambda.iter(cr.foreignKeys,function(fk) {
						if(fk.relation.name != pr.name) {
							pr.foreignKeys.push(fk);
						}
					});
					Lambda.iter(mld.relations,function(r) {
						Lambda.iter(r.foreignKeys,function(fk) {
							if(fk.relation.name == cr.name) {
								fk.relation = pr;
							}
						});
					});
					let _this1 = mld.relations;
					let key1 = cr.name;
					if(Object.prototype.hasOwnProperty.call(_this1.h,key1)) {
						delete(_this1.h[key1]);
					}
				}
			}
		}
	}
	static supersetToChildren(diagram,mld) {
		let e = haxe_ds_StringMap.valueIterator(diagram.sets.h);
		while(e.hasNext()) {
			let e1 = e.next();
			if(e1.subsetOption == model_Set.SUBSET_OPT_CHILDREN && (e1.subsets.length == 1 || e1.subsetType.toUpperCase() == "X" || e1.subsetType.toUpperCase() == "XT" || e1.subsetType.toUpperCase() == "P")) {
				let _this = mld.relations;
				let key = e1.get_codeName();
				let pr = _this.h[key];
				let _g = [];
				let x = $getIterator(e1.subsets);
				while(x.hasNext()) {
					let x1 = x.next();
					_g.push(x1.get_codeName());
				}
				let subsetsNames = _g;
				let refCount = Lambda.count(mld.relations,function(r) {
					if(subsetsNames.indexOf(r.name) == -1) {
						return Lambda.exists(r.foreignKeys,function(fk) {
							return fk.relation.name == pr.name;
						});
					} else {
						return false;
					}
				});
				let _g1 = 0;
				let _g2 = e1.subsets;
				while(_g1 < _g2.length) {
					let c = _g2[_g1];
					++_g1;
					let _this = mld.relations;
					let key = c.get_codeName();
					let cr = _this.h[key];
					let pos = cr.key.length - 1;
					let _g = 0;
					let _g3 = pr.fields;
					while(_g < _g3.length) {
						let f = _g3[_g];
						++_g;
						if(pr.key.indexOf(f.name) == -1) {
							cr.fields.splice(pos,0,f);
						}
						++pos;
					}
					Lambda.iter(pr.foreignKeys,function(fk) {
						cr.foreignKeys.push(fk);
					});
					if(refCount == 0 && (e1.subsets.length == 1 || e1.subsetType.toUpperCase() == "XT" || e1.subsetType.toUpperCase() == "P")) {
						let supersetFK = [];
						Lambda.iter(cr.foreignKeys,function(fk) {
							if(fk.relation.name == pr.name) {
								supersetFK.push(fk);
							}
						});
						Lambda.iter(supersetFK,function(fk) {
							HxOverrides.remove(cr.foreignKeys,fk);
						});
					}
				}
				if(refCount == 0 && (e1.subsets.length == 1 || e1.subsetType.toUpperCase() == "XT" || e1.subsetType.toUpperCase() == "P")) {
					let _this = mld.relations;
					let key = pr.name;
					if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
						delete(_this.h[key]);
					}
				}
			}
		}
	}
	static copyLayout(diagram,mld) {
		mld.height = diagram.height;
		mld.width = diagram.width;
		let _g = [];
		let _g1 = 0;
		let _g2 = mld.height;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(0);
		}
		let rows = _g;
		let _g3 = [];
		let _g4 = 0;
		let _g5 = mld.width;
		while(_g4 < _g5) {
			let i = _g4++;
			_g3.push(0);
		}
		let columns = _g3;
		let o = diagram.iterator();
		while(o.hasNext()) {
			let o1 = o.next();
			let _this = mld.relations;
			let key = o1.get_codeName();
			let r = _this.h[key];
			if(r != null) {
				r.row = o1.row;
				r.col = o1.col;
				rows[r.row]++;
				columns[r.col]++;
			}
		}
		let empty = 0;
		let _g6 = 0;
		let _g7 = rows.length;
		while(_g6 < _g7) {
			let i = _g6++;
			if(rows[i] == 0) {
				++empty;
			} else {
				rows[i] = i - empty;
			}
		}
		mld.height -= empty;
		empty = 0;
		let _g8 = 0;
		let _g9 = columns.length;
		while(_g8 < _g9) {
			let i = _g8++;
			if(columns[i] == 0) {
				++empty;
			} else {
				columns[i] = i - empty;
			}
		}
		mld.width -= empty;
		let r = haxe_ds_StringMap.valueIterator(mld.relations.h);
		while(r.hasNext()) {
			let r1 = r.next();
			r1.row = rows[r1.row];
			r1.col = columns[r1.col];
		}
	}
}
$hx_exports["transform"]["DiagramToMLD"] = transform_DiagramToMLD;
transform_DiagramToMLD.__name__ = true;
class transform_DiagramToUML {
	static transform(diagram) {
		transform_DiagramToUML.initNavigation(diagram);
		transform_DiagramToUML.initConstructors(diagram);
		transform_DiagramToUML.initAccessors(diagram);
	}
	static initNavigation(diagram) {
		let assoc = haxe_ds_StringMap.valueIterator(diagram.associations.h);
		while(assoc.hasNext()) {
			let assoc1 = assoc.next();
			if(assoc1.isNN()) {
				if(assoc1.isClass() || assoc1.links.length > 2) {
					let _g = 0;
					let _g1 = assoc1.links;
					while(_g < _g1.length) {
						let link = _g1[_g];
						++_g;
						assoc1.navFields.push(new model_Field(transform_DiagramToUML.constructFieldName(link,"1"),link.set.get_className(),model_Field.ACCESS_UNSET));
					}
				} else {
					if(!assoc1.links[0].hasArrow) {
						let c1 = diagram.getObj(assoc1.links[0].set.name);
						c1.navFields.push(new model_Field(transform_DiagramToUML.constructFieldName(assoc1.links[1],assoc1.links[1].max),model_Field.arrayOf(assoc1.links[1].set.get_className()),model_Field.ACCESS_UNSET));
					}
					if(!assoc1.links[0].hasArrow) {
						let c2 = diagram.getObj(assoc1.links[1].set.name);
						c2.navFields.push(new model_Field(transform_DiagramToUML.constructFieldName(assoc1.links[0],assoc1.links[0].max),model_Field.arrayOf(assoc1.links[0].set.get_className()),model_Field.ACCESS_UNSET));
					}
				}
			} else {
				let l1 = null;
				let ln = null;
				let _g = 0;
				let _g1 = assoc1.links;
				while(_g < _g1.length) {
					let link = _g1[_g];
					++_g;
					if(link.max == "1") {
						l1 = link;
					} else {
						ln = link;
					}
				}
				if(!l1.hasArrow) {
					let c1 = diagram.getObj(l1.set.name);
					c1.navFields.push(new model_Field(transform_DiagramToUML.constructFieldName(ln,"1"),ln.set.get_className(),model_Field.ACCESS_UNSET));
				}
				if(!ln.hasArrow) {
					let cn = diagram.getObj(ln.set.name);
					cn.navFields.push(new model_Field(transform_DiagramToUML.constructFieldName(l1,"N"),model_Field.arrayOf(l1.set.get_className()),model_Field.ACCESS_UNSET));
				}
			}
		}
	}
	static constructFieldName(link,maxCard) {
		let fName;
		if(link.role != "") {
			fName = link.get_roleCode();
		} else {
			fName = link.set.get_codeName() + (maxCard == "N" ? "s" : "");
		}
		fName = fName.charAt(0).toLowerCase() + HxOverrides.substr(fName,1,null);
		return fName;
	}
	static initConstructors(diagram) {
		let set = haxe_ds_StringMap.valueIterator(diagram.sets.h);
		while(set.hasNext()) {
			let set1 = set.next();
			let tmp = set1.get_className();
			set1.constructor = new model_Method(tmp,"",set1.isAbstract ? model_Field.ACCESS_PROTECTED : model_Field.ACCESS_PUBLIC);
			Lambda.iter(set1.fields,function(field) {
				set1.constructor.params.push(new model_Field(field.get_codeName(),field.get_classType()));
			});
			Lambda.iter(set1.navFields,function(field) {
				if(!field.isArray()) {
					set1.constructor.params.push(new model_Field(field.get_codeName(),field.get_classType()));
				}
			});
		}
		let set1 = haxe_ds_StringMap.valueIterator(diagram.associations.h);
		while(set1.hasNext()) {
			let set = set1.next();
			if(set.isClass()) {
				let tmp = set.get_className();
				set.constructor = new model_Method(tmp,"",model_Field.ACCESS_PUBLIC);
				Lambda.iter(set.navFields,function(field) {
					set.constructor.params.push(new model_Field(field.get_codeName(),field.get_classType()));
				});
				Lambda.iter(set.fields,function(field) {
					set.constructor.params.push(new model_Field(field.get_codeName(),field.get_classType()));
				});
			}
		}
	}
	static initAccessors(diagram) {
		let set = haxe_ds_StringMap.valueIterator(diagram.sets.h);
		while(set.hasNext()) {
			let set1 = set.next();
			Lambda.iter(set1.fields,function(field) {
				transform_DiagramToUML.setAccessors(set1,field);
			});
			Lambda.iter(set1.navFields,function(field) {
				transform_DiagramToUML.setAccessors(set1,field);
			});
		}
		let set1 = haxe_ds_StringMap.valueIterator(diagram.associations.h);
		while(set1.hasNext()) {
			let set = set1.next();
			if(set.isClass()) {
				Lambda.iter(set.fields,function(field) {
					transform_DiagramToUML.setAccessors(set,field);
				});
				Lambda.iter(set.navFields,function(field) {
					transform_DiagramToUML.setAccessors(set,field);
				});
			}
		}
	}
	static setAccessors(set,field) {
		if(field.visibility == model_Field.ACCESS_UNSET) {
			field.visibility = model_Field.ACCESS_PROTECTED;
			set.accessors.push(new model_Method("get" + field.get_codeName().charAt(0).toUpperCase() + HxOverrides.substr(field.get_codeName(),1,null),field.get_dbType(),model_Field.ACCESS_PUBLIC));
			let method = new model_Method("set" + field.get_codeName().charAt(0).toUpperCase() + HxOverrides.substr(field.get_codeName(),1,null),field.get_dbType(),model_Field.ACCESS_PUBLIC);
			method.params.push(new model_Field(field.get_codeName(),field.get_dbType()));
			set.accessors.push(method);
		}
	}
}
$hx_exports["transform"]["DiagramToUML"] = transform_DiagramToUML;
transform_DiagramToUML.__name__ = true;
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
Xml.Element = 0;
Xml.PCData = 1;
Xml.Document = 6;
model_Obj.__meta__ = { statics : { fixName : { SuppressWarnings : ["checkstyle:CyclomaticComplexity"]}}};
model_Set.SUBSET_OPT_BOTH = 0;
model_Set.SUBSET_OPT_CHILDREN = 1;
model_Set.SUBSET_OPT_PARENT = 2;
model_Field.ACCESS_UNSET = 0;
model_Field.ACCESS_PRIVATE = 1;
model_Field.ACCESS_PROTECTED = 2;
model_Field.ACCESS_PUBLIC = 3;
model_Link.__meta__ = { fields : { _ : { SuppressWarnings : ["checkstyle:ParameterNumber"]}}};
schema_MCDToSVG.__meta__ = { statics : { generateLineCardsSVG : { SuppressWarnings : ["checkstyle:ParameterNumber"]}, generateArrowSVG : { SuppressWarnings : ["checkstyle:ParameterNumber"]}, generateCardsSVG : { SuppressWarnings : ["checkstyle:ParameterNumber"]}}};
schema_Svg.coordRE = new EReg("^translate\\(([0-9]+,[0-9]+)\\)$","");
schema_Svg.PADDING = 5;
schema_Svg.MARGIN = 40;
schema_Svg.IMARGIN = 10;
schema_Svg.RXY = 20;
schema_Svg.LETTER_WIDTH = 9.5;
schema_Svg.LETTER_HEIGHT = 16;
schema_Svg.TEXT_STYLE = "font-family:'Roboto Mono';font-size:16px";
schema_Svg.UNDERLINE_STYLE = "text-decoration:underline";
schema_Svg.RECT_STYLE = "stroke:black";
schema_Svg.LINE_STYLE = "fill:none;stroke:black";
schema_Svg.ARROW_STYLE = "fill:black;stroke:black";
schema_Svg.FILL_WHITE_STYLE = "fill:white";
schema_Svg.FILL_GREY_STYLE = "fill:lightgrey";
source_Mocodo.DEFAULT_TYPE = "VARCHAR(50)";
source_Mocodo.typeRE = new EReg("([^\\[]*)\\[(.*)\\]","");
source_Mocodo.entityRE = new EReg("^[^/,:(]{2,}:","");
source_Mocodo.associationRE = new EReg("^[^/,:]{2,},","");
source_Mocodo.legacySubsetRE = new EReg("([^/,:]{2,}( U [^,:]{2,})*) C( ?\\[(X?T?)\\])? ([^,:]{2,})$","i");
source_Mocodo.subsetRE = new EReg("^/([XT]{0,2}|P)?\\\\ * ([^-><]{2,}) *([-><]) *(\\[.*\\])? *(.*$)","i");
source_Mocodo.linkRE = new EReg("[_-o*]?[01NX]{2}>? *(\\[(.*)\\])?(.*)$","");
source_Mocodo.methodRE = new EReg("^[^/,:(]{2,}\\(\\):","");
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
